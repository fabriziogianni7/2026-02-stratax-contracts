# Smart Contract Basic Security Checklist

This checklist provides security guidelines and remediation steps for various aspects of smart contract development, covering access controls, array handling, mathematical operations, and more.

## Access Control

**Question** Did you clarify all the actors and their allowed interactions in the protocol?

**Description**
This is a general check item. Having a clear understanding of all relevant actors and interactions in the protocol is critical for security.

**Remediation**
List down all the actors and interactions and draw a diagram.

**Question** Are there functions lacking proper access controls?

**Description**
Access controls determine who can use certain functions of a contract. If these are missing or improperly implemented, it can expose the contract to unauthorized changes or withdrawals.

**Remediation**
Implement and rigorously test access controls like `onlyOwner` or role-based permissions to ensure only authorized users can access certain functions.

**Question** Do certain addresses require whitelisting?

**Description**
Whitelisting allows only a specific set of addresses to interact with the contract, offering an additional layer of security against malicious actors.

**Remediation**
Establish a whitelisting mechanism and ensure that only trusted addresses can execute sensitive or restricted operations.

**Question** Does the protocol allow transfer of privileges?

**Description**
Transfer of critical privileges must be done in two-step process. A two-step transfer process, usually involving a request followed by a confirmation, adds an extra layer of security against unintentional or malicious owner changes.

**Remediation**
Implement a two-step transfer mechanism that requires the new actor to accept the transfer, ensuring better security and intentional ownership changes.

**Question** What happens during the transfer of privileges?

**Description**
The protocol needs to work consistently and reasonably even during the transfer of privileges.

**Remediation**
Double check how the protocol works during the transfer of privileges.

**Question** Does the contract inherit others?

**Description**
If you do not override a parent contract's function explicitly, the parent's one will be exposed with its visibility and probably a wrong accessibiliy.

**Remediation**
Make sure you check the accessibility to the parent's external/public functions.

**Question** Does the contract use `tx.origin` in validation?

**Description**
Use of `tx.origin` for authorization may be abused by a malicious contract forwarding calls from the legitimate user. Use `msg.sender` instead. `require( tx.origin == msg.sender)` is a useful check to ensure that the `msg.sender` is an EOA(externally owned account).

**Remediation**
Make sure you know the difference of `tx.origin` and `msg.sender` and use properly.

## Array / Loop

**Question** What happens on the first and the last cycle of the iteration?

**Description**
Sometimes the first and last cycles have a different logic from others and there can be problems.

**Remediation**
Ensure the logic is correct for the first and the last cycles.

**Question** How does the protocol remove an item from an array?

**Description**
`delete` does not rearrange the array but just resets the element.

**Remediation**
Copy the last element to the index of the element to be removed and decrease the length of an array.

**Question** Does any function get an index of an array as an argument?

**Description**
If an array is supposed to be updated (removal in the middle), the indexes will change.

**Remediation**
Do not use an index of an array that is supposed to be updated as a parameter of a function.

**Question** Is the summing of variables done accurately compared to separate calculations?

**Description**
Direct calculation against a sum may yield different results than the sum of individual calculations, leading to precision issues.

**Remediation**
Ensure that summation logic is thoroughly tested and verified, especially when dealing with financial calculations to maintain accuracy.

**Question** Is it fine to have duplicate items in the array?

**Description**
In most cases, an array (especially an input array by users) is supposed to be unique.

**Remediation**
Add a validation to check the array is unique.

**Question** Is there any issue with the first and the last iteration?

**Description**
The first and the last iteration in loops can sometimes have edge cases that differ from other iterations, possibly leading to vulnerabilities.

**Remediation**
Always test the initial and the last iteration separately and ensure consistent behavior throughout all iterations.

**Question** Is there possibility of iteration of a huge array?

**Description**
Due to the block gas limit, there is a clear limitation in the amount of operation that can be handled in a transaction.

**Remediation**
Ensure the number of iterations is properly bounded.

**Question** Is there a potential for a Denial-of-Service (DoS) attack in the loop?

**Description**
Loops that contain external calls or are dependent on user-controlled input can be exploited to halt the contract's functions. (e.g. sending ETH to multiple users)

**Remediation**
Ensure a failure of a single iteration does not revert the whole operation.

**Question** Is `msg.value` used within a loop?

**Description**
`msg.value` is consistent for the whole transaction. If it is used in the for loop, it is likely there is a mistake in accounting.

**Remediation**
Avoid using `msg.value` inside loops. Refer to multi-call vulnerability.

**Question** Is there a loop to handle batch fund transfer?

**Description**
If there is a mechanism to transfer funds out based on some kind of shares, it is likely that there is a problem of 'dust' funds not handled correctly.

**Remediation**
Make sure the last transfer handles all residual.

**Question** Is there a break or continue inside a loop?

**Description**
Sometimes developers overlook the edge cases that can happened due to the break or continue in the middle of the loop.

**Remediation**
Make sure the break or continue inside a loop does not lead to unexpected behaviors.

## Block Reorganization

**Question** Does the protocol implement a factory pattern using the CREATE opcode?

**Description**
Contracts created with the CREATE opcode will be eliminated if a block reorg happens.

**Remediation**
Use CREATE2 instead of CREATE.

## Event

**Question** Does the protocol emit events on important state changes?

**Description**
Emitting events properly is important especially if the change is critical.

**Remediation**
Ensure to emit events in all important functions.

## Function

**Question** Are the inputs validated?

**Description**
Inputs to functions should be validated to prevent unexpected behavior.

**Remediation**
Ensure thorough validation. E.g. min/max for numeric values, start/end for dates, ownership of positions.

**Question** Are the outputs validated?

**Description**
Outputs of functions should be validated to prevent unexpected behavior.

**Remediation**
Ensure the outputs are valid.

**Question** Can the function be front-run?

**Description**
Front-running can allow attackers to prioritize their transactions over others.

**Remediation**
Make sure there is no unexpected risk even if attackers front-run.

**Question** Are the code comments coherent with the implementation?

**Description**
Misleading or outdated comments can result in misunderstood function behaviors.

**Remediation**
Keep comments updated and ensure they accurately describe the function logic.

**Question** Can edge case inputs (0, max) result in unexpected behavior?

**Description**
Edge input values can lead to unexpected behavior.

**Remediation**
Make sure the function works as expected for the edge values.

**Question** Does the function allow arbitrary user input?

**Description**
Implementing a function that accepts arbitrary user input and makes low-level calls based on this data introduces a significant security risk. Low-level calls in Solidity, such as call(), are powerful and can lead to unintended contract behavior if not used cautiously. With the ability for users to supply arbitrary data, they can potentially trigger unexpected paths in the contract logic, exploit reentrancy vulnerabilities, or even interact with other contracts in a malicious manner.

**Remediation**
Restrict the usage of low-level calls, especially when combined with arbitrary user input. Ensure that any data used in these calls is thoroughly validated and sanitized.

**Question** Should it be `external`/`public`?

**Description**
Ensure the visibility modifier is appropriate for the function's use, preventing unnecessary exposure.

**Remediation**
Limit function visibility to the strictest level possible (`private` or `internal`).

**Question** Does this function need to be called by only EOA or only contracts?

**Description**
There are several edge cases regarding the caller checking mechanism, both for EOA and contracts.

**Remediation**
Ensure the correct access control is implemented according to the protocol's context. (read all the references)

**Question** Does this function need to be restricted for specific callers?

**Description**
Ensure that functions modifying contract state or accessing sensitive operations are access-controlled.

**Remediation**
Implement access control mechanisms like `onlyOwner` or custom modifiers.

## Inheritance

**Question** Is it necessary to limit visibility of parent contract's public functions?

**Description**
External/Public functions of all parent contracts will be exposed with the same visibility as long as they are not overridden.

**Remediation**
Make sure to expose only relevant functions from parent contracts.

**Question** Were all necessary functions implemented to fulfill inheritance purpose?

**Description**
Parent contracts often assume the inheriting contracts to implement public functions to utilize the parent's functionality. Sometimes developers miss implementing them and it makes the inheritance useless.

**Remediation**
Make sure to expose relevant functions from parent contracts.

**Question** Has the contract implemented an interface?

**Description**
Interfaces are used by other protocols to interact with the protocol. Missing implementation will lead to unexpected cases.

**Remediation**
Make sure to implement all functions specified in the interface.

**Question** Does the inheritance order matter?

**Description**
Inheriting contracts in the wrong order can lead to unexpected behavior, e.g. storage allocation.

**Remediation**
Verify the inheritance chain is ordered from 'most base-like' to 'most derived' to prevent issues like incorrect variable initialization.

## Initialization

**Question** Are important state variables initialized properly?

**Description**
Overlooking explicit initialization of state variables can lead to critical issues.

**Remediation**
Make sure to initialize all state variables correctly.

**Question** Has the contract inherited OpenZeppelin's Initializable?

**Description**
If the contract is supposed to be inherited by other contracts, `onlyInitializing` modifier MUST be used instead of `initializer`.

**Remediation**
Make sure to use the correct modifier for the initializer function.

**Question** Does the contract have a separate initializer function other than a constructor?

**Description**
Initializer function can be front-run right after the deployment. The impact is critical if the initializer sets the access controls.

**Remediation**
Use the factory pattern to allow only the factory to call the initializer or ensure it is not front-runnable in the deploy script.

## Map

**Question** Is there need to delete the existing item from a map?

**Description**
If a variable of nested structure is deleted, only the top-level fields are reset by default values (zero) and the nested level fields are not reset.

**Remediation**
Always ensure that inner fields are deleted before the outer fields of the structure.

## Math

**Question** Is the mathematical calculation accurate?

**Description**
Ensure that the logic behind any mathematical operation is correctly implemented.

**Remediation**
Verify calculations against established mathematical rules in the document or the comments.

**Question** Is there any loss of precision in time calculations?

**Description**
Loss of precision can lead to significant errors over time or frequent calculations.

**Remediation**
Use appropriate data types and ensure rounding methods are correctly applied.

**Question** Are you aware that expressions like `1 day` are cast to `uint24`, potentially causing overflows?

**Description**
Operations with certain expressions might lead to unintended data type conversions.

**Remediation**
Always be explicit with data types and avoid relying on implicit type conversions.

**Question** Is there any case where dividing is done before multiplication?

**Description**
Multiplying before division is generally better to keep the precision.

**Remediation**
To avoid loss of precision, always multiply first and then divide.

**Question** Does the rounding direction matter?

**Description**
Rounding direction often matters when the accounting relies on user's shares.

**Remediation**
Use the proper rounding direction in favor of the protocol

**Question** Is there a possibility of division by zero?

**Description**
Division by zero will revert the transaction.

**Remediation**
Always check denominators before division.

**Question** Even in versions like `>0.8.0`, have you ensured variables won't underflow or overflow leading to reverts?

**Description**
Variables can sometimes exceed their bounds, causing reverts.

**Remediation**
Use checks to prevent variable underflows and overflows.

**Question** Are you aware that assigning a negative value to an unsigned integer causes a revert?

**Description**
Unsigned integers cannot hold negative values.

**Remediation**
Always ensure that only non-negative values are assigned to unsigned integers.

**Question** Have you properly reviewed all usages of `unchecked{}`?

**Description**
Arithmetics do not overflow inside the `unchecked{}` block.

**Remediation**
Use `unchecked{}` only when it is strictly guaranteed that no overflow/underflow happens.

**Question** In comparisons using < or >, should you instead be using ≤ or ≥?

**Description**
Usage of incorrect inequality can cause unexpected behavior for the edge values.

**Remediation**
Review the logic and ensure the appropriate comparison operators are used.

**Question** Have you taken into consideration mathematical operations in inline assembly?

**Description**
Inline assembly can behave differently than high-level language constructs. (division by zero, overflow/underflow do not revert!)

**Remediation**
Ensure mathematical operations in inline assembly are properly tested and verified.

**Question** What happens for the minimum/maximum values included in the calculation?

**Description**
If the calculation includes numerous terms, you need to confirm all edge cases where each term has the possible min/max values.

**Remediation**
Ensure the edge cases do not lead to unexpected outcome.

## Payment

**Question** Is it possible for the receiver to revert?

**Description**
There are cases where a receiver contract can deny the transaction. For example, a malicious receiver can have a fallback to revert. If a caller tried to send funds using `transfer` or `send`, the whole transaction will revert. (Meanwhile, `call()` does not revert but returns a boolean)

**Remediation**
Make sure that the receiver can not deny the payment or add a backup handler with a try-catch.

**Question** Does the function gets the payment amount as a parameter?

**Description**
For ETH deposits, `msg.value` must be checked if it is not less than the amount specified.

**Remediation**
Require `msg.value==amount.

**Question** Are there vulnerabilities related to force-feeding?

**Description**
Certain actions like self-destruct, deterministic address feeding, and coinbase transactions can be used to force-feed contracts.

**Remediation**
Ensure the contract behaves as expected when receiving unexpected funds.

**Question** What is the minimum deposit/withdrawal amount?

**Description**
Dust deposit/withdrawal often can lead to various vulnerabilities, e.g. rounding issue in accounting or Denial-Of-Service.

**Remediation**
Add a threshold for the deposit/withdrawal amount.

**Question** How is the withdrawal handled?

**Description**
The best practice in withdrawal process is to implement pull-based approach. Track the accounting and let users pull the payments instead of sending funds proactively.

**Remediation**
Implement pull-based approach in withdrawals.

**Question** Is `transfer()` or `send()` used for sending ETH?

**Description**
The transfer() and send() functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction.

**Remediation**
Use `call()` to prevent potential gas issues.

**Question** Is it possible for native ETH to be locked in the contract?

## Proxy/Upgradable

**Question** Is there a constructor in the proxied contract?

**Description**
Proxied contract can't have a constructor and it's common to move constructor logic to an external initializer function, usually called initialize

**Remediation**
Use initializer functions for initialization of proxied contracts.

**Question** Is the `initializer` modifier applied to the `initialization()` function?

**Description**
Without the `initializer` modifier, there is a risk that the initialization function can be called multiple times.

**Remediation**
Always use the `initializer` modifier for initialization functions in proxied contracts and ensure they're called once during deployment.

**Question** Is the upgradable version used for initialization?

**Description**
Upgradable contracts must use the upgradable versions of parent initializer functions. (e.g. Pausable vs PausableUpgradable)

**Remediation**
Use upgradable versions of parent initializer functions.

**Question** Is the `authorizeUpgrade()` function properly secured in a UUPS setup?

**Description**
Inadequate security on the `authorizeUpgrade()` function can allow unauthorized upgrades.

**Remediation**
Ensure proper access controls and checks are in place for the `authorizeUpgrade()` function.

**Question** Is the contract initialized?

**Description**
An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation contract, which may impact the proxy.

**Remediation**
To prevent the implementation contract from being used, invoke the `_disableInitializers` function in the constructor to automatically lock it when it is deployed.

**Question** Are `selfdestruct` and `delegatecall` used within the implementation contracts?

**Description**
Using `selfdestruct` and `delegatecall` in implementation contracts can introduce vulnerabilities and unexpected behavior in a proxy setup.

**Remediation**
Avoid using `selfdestruct` and `delegatecall` in implementation contracts to ensure contract stability and security.

**Question** Are values in immutable variables preserved between upgrades?

**Description**
Immutable variables are stored in the bytecode, not in the proxy storage. So using immutable variable is not recommended in proxy setup. If used, make sure all immutables stay consistent across implementations during upgrades.

**Remediation**
Avoid using immutable variables in upgradable contracts.

**Question** Has the contract inherited the correct branch of OpenZeppelin library?

**Description**
Sometimes developers overlook and use an incorrect branch of OZ library, e.g. use Ownable instead of OwnableUpgradeable.

**Remediation**
Make sure inherit the correct branch of OZ library according to the contract's upgradeability design.

**Question** Could an upgrade of the contract result in storage collision?

**Description**
Storage collisions can occur when storage layouts between contract versions conflict, leading to data corruption and unpredictable behavior.

**Remediation**
Maintain a consistent storage layout between upgrades, and when using inheritance, set storage gaps to avoid potential collisions.

**Question** Are the order and types of storage variables consistent between upgrades?

**Description**
Changing the order or type of storage variables between upgrades can lead to storage collisions.

**Remediation**
Maintain a consistent order and type for storage variables across contract versions to avoid storage collisions.

## Type

**Question** Is there a forced type casting?

**Description**
Explicit type casting does not revert on overflow/underflow.

**Remediation**
Avoid a forced type casting as much as possible and ensure values are in the range of type limit.

**Question** Does the protocol use time units like `days`?

**Description**
The time units are of `uint8` type and this can lead to unintended overflow.

**Remediation**
Double check the calculations including time units and ensure there is no overflow for reasonable values.
